

### **Important
1. Still java 25 there no changes in Memory model after Java 5 & 8.
2. In future, they work for Valhalla (JMM).
3. \*Evolution in java 21 Virtual Thread. Update later.
#### **Heap
- Heap is managed all the objects. It has two generation,
	1. New Generation (Eden, Survivor s0, s1) 
	2. Old Generation
- Occupied, Memory spaces
	1. First and last are Reserved to maximize heap size(First 10%, last 10%).
	2. 40% for New Generation (20% for Eden, 10% for s0, another 10% for s1).
	3. 40% for Old Generation.
- When Object creates it will stores in Eden space. after time period minor GC runs to move free survivor.
- Long live object are moved to old generation after runs long GC.
- Minor GC fast pause short time, but Major GC Slow/ Long Pause time, in java 25 Generational Shenandoah reduced Old generation  pausing time. \*Update on GC Part.
- More Relation between Heap and GC, It will update on GC part.
#### **Stack
- Java by default supports stack, so when started working into to java should process on [[#**Thread Mechanism|thread]].
- Each thread has it's own stack to stores temporary execution values.
- It's stores local variables, Objects reference([[Call by Value]]) which is creates runtime, method return value.
- Each Stack entry is [[#**Stack Frame| Stack Frame]].
- The default size for 1MB.
- Experiment with *jcmd* for heap dumps or write a recursive app to hit StackOverflow.
#### **Stack Frame
- Each methods has it's own stack frame, to handles the methods.
- Native methods, Inline methods (like Math. Abs()), constructor call, lambda/anonymous, (java 21+)  virtual threads these are.
- Edge case responses so wouldn't create stack frames. // **This edge cases update later.
- The stack frame contains,
	1. Local fields array - which contains 0 index for current object address (this) , rest following index contains the values parameter, local variables and Object references.
	2. Operand stack - which is used for perform the operation like (a + b). Operand stack is stores the return values.
	3. Dynamic Linking - It's used like caching of the symbols resolution if the method again get execute it's know where the method spotted in metaspace.
	4. Return Address / Frame Data - Here, It's stores return address and exception handles of the code. 

#### **Method Area or Metaspace:
1. Method area is stores the all the bytecodes and it's called perm or Metaspace. 
	1. In runtime, It's stores the java code and constant variables and static fields.
	2. Before java 8, It's inside the heap in Perm gen space, often get outofmemoryerror,
		avoid this error after java 8+ completely outside of the heap.
	3. It's in auto expand and shrink based on pc memory size.

#### **PC (Program Counter)
- Program counter is stores the memory index, to execute next instruction step to System, CPU follow the instruction based on PC stores.
- Each thread has it's own PC to avoid conflict.
#### **Code Caching
- It's stores the Optimize code which learned and generated by JIT complier.
- Java 25 introduced for AOT Cache for faster start up.
#### **Thread Mechanism
- Thread is subunit of process (Process is a application or group task. e.g. Web browser, Other application).
- A process have multiple task that are divided work. When this handles multi task in parallelly it's called multi-thread.
- In Modern OS default handles thread in **Pre-emptive Multi-Threading** and time slicing concept.
- Thread concept fully optimized in java 25, it used (co & pre-emptive) Threads.

#### **Type of Thread 
1. Co-operative
2. Pre-emptive
#### **Co-operative
- Scheduling Thread for only worker available, and their own lifecycle, after assigned to worker couldn't take control back. 
- If existing task never ends, the worker can't free, so never assign new task.
### **Pre-emptive Multi-Threading**
- Pre-emptive thread takes full control of scheduled task with time slicing, and continues on another task in **Round Robin Technique** for existing thread processed core.
- Time slicing for default timing ~10ms to ~100ms. An, it's adjustable only admin of system.
-  If the task complete or not doesn't bother after expired time save the current state and then replace another task to that place.
